# lec4: lab1 SPOC思考题

##**提前准备**
（请在上课前完成）

 - 完成lec4的视频学习和提交对应的在线练习
 - git pull ucore_os_lab, v9_cpu, os_course_spoc_exercises in github repos。这样可以在本机上完成课堂练习。
 - 了解x86的保护模式，段选择子，全局描述符，全局描述符表，中断描述符表等概念，以及如何读写，设置等操作
 - 了解Linux中的ELF执行文件格式
 - 了解外设:串口，并口，时钟，键盘,CGA，已经如何对这些外设进行编程
 - 了解x86架构中的mem地址空间和io地址空间
 - 了解x86的中断处理过程（包括硬件部分和软件部分）
 - 了解GCC的x86/RV内联汇编
 - 了解C语言的可函数变参数编程
 - 了解qemu的启动参数的含义
 - 在piazza上就lec3学习中不理解问题进行提问
 - 学会使用 qemu
 - 在linux系统中，看看 /proc/cpuinfo的内容

## 思考题

### 启动顺序

1. x86段寄存器的字段含义和功能有哪些？

	> 答：代码段寄存器 CS（Code Segment）存放当前正在运行的程序代码所在段的段基址，表示当前使用的指令代码可以从该段寄存器指定的存储器段中取得，相应的偏移量则由IP提供。  
	　　数据段寄存器 DS（Data Segment）指出当前程序使用的数据所存放段的最低地址，即存放数据段的段基址。  
	　　堆栈段寄存器 SS（Stack Segment）指出当前堆栈的底部地址，即存放堆栈段的段基址。  
	　　附加段寄存器 ES（Extra Segment）指出当前程序使用附加数据段的段基址，该段是串操作指令中目的串所在的段。  
	　　附加段寄存器 FS  
	　　附加段寄存器 GS  
	　　FS, GS 是 80386 起增加的两个辅助段寄存器, 在这之前只有一个辅助段寄存器 ES, 增加这两个寄存器是为了减轻 ES 寄存器的负担, 并能更好地配合适用于通用寄存器组的基址和变址寄存器。这两个是通用的段寄存器，语法上同其它的段寄存器一样，不能直接用立即数给它赋值。

2. x86描述符特权级DPL、当前特权级CPL和请求特权级RPL的含义是什么？在哪些寄存器中存在这些字段？对应的访问条件是什么？

	> 答： CPL是当前进程的权限级别(Current Privilege Level)，是当前正在执行的代码所在的段的特权级，存在于 cs 寄存器的低两位。  
　　RPL说明的是进程对段访问的请求权限(Request Privilege Level)，是对于段选择子而言的，每个段选择子有自己的 RPL，它说明的是进程对段访问的请求权限，有点像函数参数。而且 RPL 对每个段来说不是固定的，两次访问同一段时的 RPL 可以不同。RPL 可能会削弱 CPL 的作用，例如当前 CPL = 0 的进程要访问一个数据段，它把段选择符中的 RPL 设为 3，这样虽然它对该段仍然只有特权为 3 的访问权限。RPL是段选择子里面的bit 0和bit 1位组合所得的值。  
　　DPL存储在段描述符中，规定访问该段的权限级别(Descriptor Privilege Level)，每个段的DPL 固定。进程访问一个段时，需要进程特权级检查，一般要求DPL >= max {CPL, RPL}，DPL是段描述符中的特权级。


3. 分析可执行文件格式elf的格式（无需回答）

### 4.1 C函数调用的实现

### 4.2 x86中断处理过程

1. x86/RV中断处理中硬件压栈内容？用户态中断和内核态中断的硬件压栈有什么不同？

	> 答：将系统当前使用的栈切换成新的内核栈。这个栈就是即将运行的中断服务程序要使用的栈。将当前程序使用的用户态的 ss 和 esp 压到新的内核栈中保存起来；CPU需要开始保存当前被打断的程序的现场（即一些寄存器的值），以便于将来恢复被打断的程序继续执行。这需要利用内核栈来保存相关现场信息，即依次压入当前被打断程序使用的 eflags， cs，eip，errorCode（如果是有错误码的异常）信息。
	
2. 为什么在用户态的中断响应要使用内核堆栈？

	> 答：因为这样可以保护中断服务例程代码的安全。

3. x86中trap类型的中断门与interrupt类型的中断门有啥设置上的差别？如果在设置中断门上不做区分，会有什么可能的后果?

	> 答：在调用 Interrupt Gate 时，Interrupt 会被 CPU 自动禁止；而调用 Trap Gate 时，CPU 则不会去禁止或打开中断，而是保留它原来的样子。如果在设置上不做区分，会导致重复触发中断。所谓“自动禁止”，指的是 CPU 跳转到 interrupt gate 里的地址时，在将 EFLAGS 保存到栈上之后，清除 EFLAGS 里的 IF 位，以避免重复触发中断。在中断处理例程里，操作系统可以将 EFLAGS 里的 IF 设上, 从而允许嵌套中断。但是必须在此之前做好处理嵌套中断的必要准备，如保存必要的寄存器等。二在 ucore 中访问 Trap Gate 的目的是为了实现系统调用。用户进程在正常执行中是不能禁止中断的，而当它发出系统调用后，将通过 Trap Gate 完成了从用户态（ring 3）的用户进程进了核心态（ring 0）的 OS kernel。如果在到达 OS kernel 后禁止 EFLAGS 里的 IF 位，第一没意义（因为不会出现嵌套系统调用的情况），第二还会导致某些中断得不到及时响应，所以调用 Trap Gate 时，CPU 则不会去禁止中断。总之，interrupt gate 和 trap gate 之间没有优先级之分，仅仅是 CPU 在处理中断时有不同的方法，供操作系统在实现时根据需要进行选择。

### 4.3 练习四和五 ucore内核映像加载和函数调用栈分析

1. ucore中，在kdebug.c文件中用到的函数`read_ebp`是内联的，而函数`read_eip`不是内联的。为什么要设计成这样？

	> 答：因为 ebp 的值可以直接获得，若不内联则会得到错误的 ebp 值。但是没有直接获取 eip 值的指令，我们需要利用 call 指令将 eip 压栈的特性，通过调用 read\_eip 函数来读出压在栈上的 eip 的值。若将 read\_eip 内联，则不会有函数调用存在，无法获得 eip 的值。
	
		static __noinline uint32_t
		read_eip(void) {
		    uint32_t eip;
		    asm volatile("movl 4(%%ebp), %0" : "=r" (eip));
		    return eip;
		}

### 4.4 练习六 完善中断初始化和处理

1. CPU加电初始化后中断是使能的吗？为什么？

	> 答：不是。CPU启动后，BIOS会在POST自检完成后在内存中建立中断向量表和中断服务程序。

## 开放思考题

1. 在ucore/rcore中如何修改lab1, 实现在出现除零异常时显示一个字符串的异常服务例程？
2. 在ucore lab1/bin目录下，通过`objcopy -O binary kernel kernel.bin`可以把elf格式的ucore kernel转变成体积更小巧的binary格式的ucore kernel。为此，需要如何修改lab1的bootloader, 能够实现正确加载binary格式的ucore OS？ (hard)
3. GRUB是一个通用的x86 bootloader，被用于加载多种操作系统。如果放弃lab1的bootloader，采用GRUB来加载ucore OS，请问需要如何修改lab1, 能够实现此需求？ (hard)
4. 如果没有中断，操作系统设计会有哪些问题或困难？在这种情况下，能否完成对外设驱动和对进程的切换等操作系统核心功能？

## 课堂实践
### 练习一
在Linux系统的应用程序中写一个函数print_stackframe()，用于获取当前位置的函数调用栈信息。实现如下一种或多种功能：函数入口地址、函数名信息、参数调用参数信息、返回值信息。

### 练习二
在ucore/rcore内核中写一个函数print_stackframe()，用于获取当前位置的函数调用栈信息。实现如下一种或多种功能：函数入口地址、函数名信息、参数调用参数信息、返回值信息。
